<!DOCTYPE html>
<html>
<head>
    <script src="https://aframe.io/releases/1.7.1/aframe.min.js"></script>
</head>
<body>
    <a-scene background="color: #87CEEB" renderer="antialias: true; colorManagement: true">
        <!-- Enhanced lighting -->
        <a-light type="ambient" color="#404040" intensity="0.6"></a-light>
        <a-light type="directional" position="0 5 0" color="#ffffff" intensity="1.2" 
                 shadow="type: pcf; mapSize: 2048"></a-light>
        
        <!-- Ground with improved materials -->
        <a-plane position="0 -1 0" rotation="-90 0 0" width="8" height="100" 
                 material="color: #4a9a4a; roughness: 0.8; metalness: 0.1"
                 shadow="receive: true"></a-plane>
        
        <!-- Player camera/avatar -->
        <a-camera id="player" position="0 1.6 0" wasd-controls="enabled: false" 
                  look-controls="enabled: false">
            <!-- Player visual indicator -->
            <a-sphere position="0 -0.5 -1.5" radius="0.2" 
                     material="color: #4285f4; metalness: 0.3; roughness: 0.4"
                     shadow="cast: true"></a-sphere>
        </a-camera>
        
        <!-- Obstacles container -->
        <a-entity id="obstacles"></a-entity>
        
        <!-- UI Elements with improved typography -->
        <a-text id="instructions" position="0 2.5 -4" align="center" 
                value="SPACEBAR = Jump | S = Duck | R = Stand\nClick = Jump (mobile)\nActions can be interrupted!" 
                material="color: white; shader: msdf" width="5" font="roboto"></a-text>
        
        <a-text id="score" position="-3 2.8 -4" align="left" 
                value="Score: 0" material="color: yellow; shader: msdf" 
                width="4" font="roboto"></a-text>
        
        <a-text id="gameOver" position="0 2 -4" align="center" 
                value="GAME OVER!\nClick to Restart" 
                material="color: red; shader: msdf" width="8" 
                font="roboto" visible="false"></a-text>
    </a-scene>

    <script>
        // Game state
        let isGameActive = true;
        let playerY = 1.6;
        let obstacles = [];
        let score = 0;
        let obstacleSpeed = 0.08;
        let spawnRate = 3500;
        let isPlayerMoving = false;
        let collisionImmune = false; // Add collision immunity tracking

        // DOM elements
        const player = document.querySelector('#player');
        const obstacleContainer = document.querySelector('#obstacles');
        const scoreText = document.querySelector('#score');
        const gameOverText = document.querySelector('#gameOver');
        const instructionsText = document.querySelector('#instructions');

        // Create obstacles with better randomization
        function createObstacle() {
            if (!isGameActive) return;

            const obstacle = document.createElement('a-box');
            // 30% chance for high, 70% chance for low
            const isHighObstacle = Math.random() < 0.3;
            const xPos = (Math.random() - 0.5) * 2;
            
            obstacle.setAttribute('position', {
                x: xPos,
                y: isHighObstacle ? 2.2 : 0.5,
                z: -25
            });
            
            obstacle.setAttribute('geometry', {
                width: 1,
                height: isHighObstacle ? 1.8 : 1,
                depth: 1
            });
            
            obstacle.setAttribute('material', {
                color: isHighObstacle ? '#e74c3c' : '#c0392b',
                roughness: 0.3,
                metalness: 0.7,
                emissive: '#330000',
                emissiveIntensity: 0.1
            });
            
            obstacle.setAttribute('shadow', 'cast: true; receive: true');
            
            obstacle.setAttribute('animation', {
                property: 'rotation',
                to: '0 360 0',
                dur: 4000,
                loop: true,
                easing: 'linear'
            });

            obstacle.setAttribute('animation__pulse', {
                property: 'scale',
                to: '1.1 1.1 1.1',
                dur: 1500,
                dir: 'alternate',
                loop: true,
                easing: 'easeInOutSine'
            });

            obstacleContainer.appendChild(obstacle);
            obstacles.push({
                element: obstacle,
                isHigh: isHighObstacle,
                x: xPos
            });
        }

        // Game loop
        function gameLoop() {
            if (!isGameActive) return;

            obstacles.forEach((obs, index) => {
                const pos = obs.element.getAttribute('position');
                pos.z += obstacleSpeed;
                obs.element.setAttribute('position', pos);

                if (pos.z > 3) {
                    obs.element.remove();
                    obstacles.splice(index, 1);
                    score += 10;
                    updateScore();
                }

                if (checkCollision(pos, obs)) {
                    gameOver();
                    return;
                }
            });

            requestAnimationFrame(gameLoop);
        }

        // Updated collision detection with immunity check
        function checkCollision(obstaclePos, obstacle) {
            // Skip collision check if player is immune (transitioning)
            if (collisionImmune) {
                return false;
            }
            
            const playerPos = player.getAttribute('position');
            
            // Only check collision when obstacle is very close (smaller window)
            if (obstaclePos.z > -0.5 && obstaclePos.z < 0.5) {
                // Check if player and obstacle are in the same horizontal lane
                if (Math.abs(obstaclePos.x - playerPos.x) < 0.8) {
                    
                    if (obstacle.isHigh) {
                        // High obstacles: more forgiving - need to be clearly ducking
                        if (playerPos.y > 1.2) { 
                            console.log(`HIT HIGH OBSTACLE! Player Y: ${playerPos.y.toFixed(2)}, needed to duck (below 1.2)`);
                            return true;
                        }
                    } else {
                        // Low obstacles: more forgiving - need to be clearly jumping
                        if (playerPos.y < 1.8) { 
                            console.log(`HIT LOW OBSTACLE! Player Y: ${playerPos.y.toFixed(2)}, needed to jump (above 1.8)`);
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        // Improved keyboard controls with collision immunity
        document.addEventListener('keydown', function(event) {
            if (!isGameActive) return;
            
            // Clear any existing animations and timers
            player.removeAttribute('animation__move');
            player.removeAttribute('animation__return');
            
            if (event.code === 'Space') {
                // SPACEBAR = JUMP
                playerY = 2.4;
                isPlayerMoving = true;
                collisionImmune = true; // Immune during transition
                
                player.setAttribute('animation__move', {
                    property: 'position',
                    to: `0 ${playerY} 0`,
                    dur: 200,
                    easing: 'easeOutCubic'
                });
                console.log('SPACEBAR - JUMPING!');
                
                // Remove immunity once jump is complete
                setTimeout(() => {
                    collisionImmune = false;
                }, 250);
                
                // Auto-return after 2 seconds
                setTimeout(() => {
                    if (playerY === 2.4) {
                        collisionImmune = true; // Immune during return
                        playerY = 1.6;
                        player.setAttribute('animation__return', {
                            property: 'position',
                            to: `0 ${playerY} 0`,
                            dur: 300,
                            easing: 'easeInOutCubic'
                        });
                        setTimeout(() => {
                            isPlayerMoving = false;
                            collisionImmune = false; // Remove immunity when stable
                        }, 350);
                    }
                }, 2000);
                
            } else if (event.code === 'KeyS') {
                // S KEY = DUCK
                playerY = 0.8;
                isPlayerMoving = true;
                collisionImmune = true; // Immune during transition
                
                player.setAttribute('animation__move', {
                    property: 'position',
                    to: `0 ${playerY} 0`,
                    dur: 200,
                    easing: 'easeOutCubic'
                });
                console.log('S KEY - DUCKING!');
                
                // Remove immunity once duck is complete
                setTimeout(() => {
                    collisionImmune = false;
                }, 250);
                
                // Auto-return after 2 seconds
                setTimeout(() => {
                    if (playerY === 0.8) {
                        collisionImmune = true; // Immune during return
                        playerY = 1.6;
                        player.setAttribute('animation__return', {
                            property: 'position',
                            to: `0 ${playerY} 0`,
                            dur: 300,
                            easing: 'easeInOutCubic'
                        });
                        setTimeout(() => {
                            isPlayerMoving = false;
                            collisionImmune = false; // Remove immunity when stable
                        }, 350);
                    }
                }, 2000);
                
            } else if (event.code === 'KeyR') {
                // R KEY = Return to normal position immediately
                collisionImmune = true;
                playerY = 1.6;
                isPlayerMoving = false;
                
                player.removeAttribute('animation__move');
                player.removeAttribute('animation__return');
                
                player.setAttribute('animation__return', {
                    property: 'position',
                    to: `0 ${playerY} 0`,
                    dur: 200,
                    easing: 'easeInOutCubic'
                });
                console.log('R KEY - RETURNING TO NORMAL!');
                
                setTimeout(() => {
                    collisionImmune = false;
                }, 250);
            }
        });

        // Updated click controls with immunity
        document.addEventListener('click', function() {
            if (!isGameActive) {
                restartGame();
                return;
            }
            
            // Clear any existing animations
            player.removeAttribute('animation__move');
            player.removeAttribute('animation__return');
            
            // Click always jumps
            playerY = 2.4;
            isPlayerMoving = true;
            collisionImmune = true; // Immune during transition
            
            player.setAttribute('animation__move', {
                property: 'position',
                to: `0 ${playerY} 0`,
                dur: 200,
                easing: 'easeOutCubic'
            });
            console.log('CLICK - JUMPING!');
            
            // Remove immunity once jump is complete
            setTimeout(() => {
                collisionImmune = false;
            }, 250);
            
            // Auto-return after 2 seconds
            setTimeout(() => {
                if (playerY === 2.4) {
                    collisionImmune = true; // Immune during return
                    playerY = 1.6;
                    player.setAttribute('animation__return', {
                        property: 'position',
                        to: `0 ${playerY} 0`,
                        dur: 300,
                        easing: 'easeInOutCubic'
                    });
                    setTimeout(() => {
                        isPlayerMoving = false;
                        collisionImmune = false; // Remove immunity when stable
                    }, 350);
                }
            }, 2000);
        });

        // Spawn obstacles with better spacing
        function spawnObstacles() {
            if (!isGameActive) return;
            
            createObstacle();
            
            // Progressive difficulty with better spacing
            if (score > 0 && score % 150 === 0) {
                obstacleSpeed = Math.min(0.15, obstacleSpeed + 0.008);
                spawnRate = Math.max(2000, spawnRate - 150);
            }
            
            // Add some randomness to spawn timing (±500ms)
            const randomDelay = spawnRate + (Math.random() - 0.5) * 1000;
            setTimeout(spawnObstacles, Math.max(2000, randomDelay));
        }

        function updateScore() {
            scoreText.setAttribute('value', `Score: ${score}`);
            scoreText.setAttribute('animation__score', {
                property: 'scale',
                to: '1.2 1.2 1.2',
                dur: 150,
                dir: 'alternate',
                loop: 2,
                easing: 'easeInOutQuad'
            });
        }

        function gameOver() {
            isGameActive = false;
            isPlayerMoving = false;
            collisionImmune = false; // Reset immunity on game over
            
            instructionsText.setAttribute('visible', false);
            gameOverText.setAttribute('visible', true);
            gameOverText.setAttribute('value', `GAME OVER!\nFinal Score: ${score}\nClick to Restart`);
            
            gameOverText.setAttribute('animation__appear', {
                property: 'scale',
                from: '0 0 0',
                to: '1 1 1',
                dur: 600,
                easing: 'easeOutBounce'
            });
        }

        function restartGame() {
            isGameActive = true;
            playerY = 1.6;
            score = 0;
            obstacleSpeed = 0.08;
            spawnRate = 3500;
            isPlayerMoving = false;
            collisionImmune = false; // Reset immunity on restart

            obstacles.forEach(obs => obs.element.remove());
            obstacles = [];

            player.setAttribute('position', '0 1.6 0');
            player.removeAttribute('animation__move');
            player.removeAttribute('animation__return');

            gameOverText.setAttribute('visible', false);
            instructionsText.setAttribute('visible', true);
            updateScore();

            gameLoop();
            setTimeout(spawnObstacles, 2000);
        }

        // Initialize game
        document.querySelector('a-scene').addEventListener('loaded', function() {
            updateScore();
            gameLoop();
            setTimeout(spawnObstacles, 3000);
        });
    </script>
</body>
</html>
