<!DOCTYPE html>
<html>
<head>
    <script src="https://aframe.io/releases/1.7.1/aframe.min.js"></script>
</head>
<body>
    <a-scene background="color: #2c3e50" renderer="antialias: true; colorManagement: true" 
             vr-mode-ui="enabled: true" device-orientation-permission-ui="enabled: true">
        <!-- Enhanced lighting -->
        <a-light type="ambient" color="#404040" intensity="0.6"></a-light>
        <a-light type="directional" position="0 5 0" color="#ffffff" intensity="1.2" 
                 shadow="type: pcf; mapSize: 2048"></a-light>
        
        <!-- Ground (hidden during intro) -->
        <a-plane id="ground" position="0 -1 0" rotation="-90 0 0" width="8" height="100" 
                 material="color: #4a9a4a; roughness: 0.8; metalness: 0.1"
                 shadow="receive: true" visible="false"></a-plane>
        
        <!-- VR Rig for Oculus -->
        <a-entity id="rig" position="0 0 0">
            <!-- Player camera/avatar with VR controls -->
            <a-camera id="player" position="0 1.6 0" wasd-controls="enabled: false" 
                      look-controls="enabled: true">
                <!-- Player visual indicator (hidden during intro) -->
                <a-sphere id="playerSphere" position="0 -0.5 -1.5" radius="0.2" 
                         material="color: #4285f4; metalness: 0.3; roughness: 0.4"
                         shadow="cast: true" visible="false"></a-sphere>
            </a-camera>

            <!-- Oculus Touch Controllers -->
            <a-entity id="leftHand" 
                      hand-controls="hand: left; handModelStyle: lowPoly; color: #ffcccc"
                      oculus-touch-controls="hand: left"
                      raycaster="objects: .clickable"
                      line="color: #118A7E"></a-entity>

            <a-entity id="rightHand" 
                      hand-controls="hand: right; handModelStyle: lowPoly; color: #ffcccc"
                      oculus-touch-controls="hand: right"
                      raycaster="objects: .clickable"
                      line="color: #118A7E"></a-entity>
        </a-entity>
        
        <!-- Obstacles container (hidden during intro) -->
        <a-entity id="obstacles" visible="false"></a-entity>
        
        <!-- Very Compact Introduction Screen -->
        <a-entity id="introScreen" visible="true">
            <!-- Small centered background -->
            <a-plane position="0 0 -2.5" width="4.5" height="2.8" 
                     material="color: #34495e; opacity: 0.95"></a-plane>
            
            <!-- Title -->
            <a-text position="0 1.2 -2.4" align="center" 
                    value="AVOID THE OBSTACLES" 
                    material="color: #e74c3c; shader: msdf" width="6" font="roboto"></a-text>
            
            <!-- Condensed Win/Lose -->
            <a-text position="0 0.8 -2.4" align="center" 
                    value="🎯 Survive • 💀 Don't touch red boxes • 🏆 Beat high score" 
                    material="color: #2ecc71; shader: msdf" width="3" font="roboto"></a-text>
            
            <!-- Controls -->
            <a-text position="0 0.4 -2.4" align="center" 
                    value="SPACEBAR = Jump | S = Duck" 
                    material="color: #3498db; shader: msdf" width="2.5" font="roboto"></a-text>
            
            <!-- Strategy -->
            <a-text position="0 0 -2.4" align="center" 
                    value="Jump over short • Duck under tall" 
                    material="color: #95a5a6; shader: msdf" width="2.5" font="roboto"></a-text>
            
            <!-- Start Button -->
            <a-box id="startButton" position="0 -0.5 -2.3" width="1.8" height="0.3" depth="0.1"
                   material="color: #27ae60; roughness: 0.3; metalness: 0.7"
                   class="clickable"
                   animation="property: scale; to: 1.1 1.1 1.1; dur: 1000; dir: alternate; loop: true">
                <a-text position="0 0 0.06" align="center" 
                        value="START" 
                        material="color: white; shader: msdf" width="4" font="roboto"></a-text>
            </a-box>
            
            <!-- Simple instruction -->
            <a-text position="0 -0.9 -2.4" align="center" 
                    value="Click START or press SPACEBAR" 
                    material="color: #e67e22; shader: msdf" width="2.5" font="roboto"></a-text>
        </a-entity>
        
        <!-- Game UI Elements (hidden during intro) -->
        <a-text id="instructions" position="0 2.5 -4" align="center" 
                value="SPACEBAR = Jump | S = Duck | R = Stand" 
                material="color: white; shader: msdf" width="4" font="roboto"
                look-at="#player" visible="false"></a-text>
        
        <a-text id="score" position="-3 2.8 -4" align="left" 
                value="Score: 0" material="color: yellow; shader: msdf" 
                width="4" font="roboto"
                look-at="#player" visible="false"></a-text>
        
        <a-text id="timer" position="3 2.8 -4" align="right" 
                value="Time: 0:00" material="color: #00ff00; shader: msdf" 
                width="4" font="roboto"
                look-at="#player" visible="false"></a-text>
        
        <!-- Win/Lose status indicator during gameplay -->
        <a-text id="statusText" position="0 3.2 -4" align="center" 
                value="🎯 Avoid the red obstacles to survive!" 
                material="color: #f39c12; shader: msdf" width="4" font="roboto"
                look-at="#player" visible="false"></a-text>
        
        <a-text id="gameOver" position="0 2 -4" align="center" 
                value="GAME OVER!\nClick to Restart" 
                material="color: red; shader: msdf" width="6" 
                font="roboto" visible="false"
                look-at="#player"></a-text>

        <!-- VR Control Indicators -->
        <a-text id="vrStatus" position="0 -3.5 -4" align="center" 
                value="VR Ready!" material="color: green; shader: msdf" 
                width="3" font="roboto" visible="false"
                look-at="#player"></a-text>
    </a-scene>

    <script>
        // Game state
        let isGameActive = false;
        let gameStarted = false;
        let playerY = 1.6;
        let obstacles = [];
        let score = 0;
        let obstacleSpeed = 0.08;
        let spawnRate = 3500;
        let isPlayerMoving = false;
        let isVRMode = false;
        
        // Timer variables
        let gameStartTime = 0;
        let gameTime = 0;
        let timerInterval = null;
        
        // High score tracking
        let bestScore = localStorage.getItem('bestScore') || 0;
        let bestTime = localStorage.getItem('bestTime') || 0;

        // DOM elements
        const player = document.querySelector('#player');
        const rig = document.querySelector('#rig');
        const ground = document.querySelector('#ground');
        const playerSphere = document.querySelector('#playerSphere');
        const obstacleContainer = document.querySelector('#obstacles');
        const scoreText = document.querySelector('#score');
        const timerText = document.querySelector('#timer');
        const statusText = document.querySelector('#statusText');
        const gameOverText = document.querySelector('#gameOver');
        const instructionsText = document.querySelector('#instructions');
        const vrStatusText = document.querySelector('#vrStatus');
        const leftHand = document.querySelector('#leftHand');
        const rightHand = document.querySelector('#rightHand');
        const introScreen = document.querySelector('#introScreen');
        const startButton = document.querySelector('#startButton');

        // Detect VR mode
        document.querySelector('a-scene').addEventListener('enter-vr', function() {
            isVRMode = true;
            if (gameStarted) vrStatusText.setAttribute('visible', true);
        });

        document.querySelector('a-scene').addEventListener('exit-vr', function() {
            isVRMode = false;
            vrStatusText.setAttribute('visible', false);
        });

        // Timer functions
        function startTimer() {
            gameStartTime = Date.now();
            gameTime = 0;
            timerInterval = setInterval(updateTimer, 100);
        }

        function updateTimer() {
            if (!isGameActive) return;
            
            gameTime = Math.floor((Date.now() - gameStartTime) / 1000);
            const minutes = Math.floor(gameTime / 60);
            const seconds = gameTime % 60;
            const timeString = `Time: ${minutes}:${seconds.toString().padStart(2, '0')}`;
            
            timerText.setAttribute('value', timeString);
            
            // Update status based on performance
            if (gameTime > 0 && gameTime % 30 === 0) {
                statusText.setAttribute('value', `🔥 ${gameTime} seconds survived! Keep going!`);
                statusText.setAttribute('animation', {
                    property: 'scale',
                    to: '1.2 1.2 1.2',
                    dur: 300,
                    dir: 'alternate',
                    loop: 2
                });
            }
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        function formatFinalTime() {
            const minutes = Math.floor(gameTime / 60);
            const seconds = gameTime % 60;
            return `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        // Save high scores
        function saveHighScores() {
            if (score > bestScore) {
                bestScore = score;
                localStorage.setItem('bestScore', bestScore);
            }
            if (gameTime > bestTime) {
                bestTime = gameTime;
                localStorage.setItem('bestTime', bestTime);
            }
        }

        // Start Button Click Handler
        startButton.addEventListener('click', startGame);

        // Start the game
        function startGame() {
            if (gameStarted) return;
            
            gameStarted = true;
            isGameActive = true;
            
            document.querySelector('a-scene').setAttribute('background', 'color: #87CEEB');
            
            introScreen.setAttribute('animation', {
                property: 'scale',
                to: '0 0 0',
                dur: 400,
                easing: 'easeInCubic'
            });
            
            setTimeout(() => {
                introScreen.setAttribute('visible', false);
                ground.setAttribute('visible', true);
                playerSphere.setAttribute('visible', true);
                obstacleContainer.setAttribute('visible', true);
                instructionsText.setAttribute('visible', true);
                scoreText.setAttribute('visible', true);
                timerText.setAttribute('visible', true);
                statusText.setAttribute('visible', true);
                if (isVRMode) vrStatusText.setAttribute('visible', true);
                
                updateScore();
                startTimer();
                gameLoop();
                setTimeout(spawnObstacles, 2000);
            }, 400);
        }

        // Create obstacles
        function createObstacle() {
            if (!isGameActive) return;

            const obstacle = document.createElement('a-box');
            const isHighObstacle = Math.random() < 0.3;
            const xPos = (Math.random() - 0.5) * 2;
            
            obstacle.setAttribute('position', {
                x: xPos,
                y: isHighObstacle ? 2.2 : 0.5,
                z: -25
            });
            
            obstacle.setAttribute('geometry', {
                width: 1,
                height: isHighObstacle ? 1.8 : 1,
                depth: 1
            });
            
            obstacle.setAttribute('material', {
                color: isHighObstacle ? '#e74c3c' : '#c0392b',
                roughness: 0.3,
                metalness: 0.7,
                emissive: '#330000',
                emissiveIntensity: 0.1
            });
            
            obstacle.setAttribute('shadow', 'cast: true; receive: true');
            
            obstacle.setAttribute('animation', {
                property: 'rotation',
                to: '0 360 0',
                dur: 4000,
                loop: true,
                easing: 'linear'
            });

            obstacle.setAttribute('animation__pulse', {
                property: 'scale',
                to: '1.1 1.1 1.1',
                dur: 1500,
                dir: 'alternate',
                loop: true,
                easing: 'easeInOutSine'
            });

            obstacleContainer.appendChild(obstacle);
            obstacles.push({
                element: obstacle,
                isHigh: isHighObstacle,
                x: xPos
            });
        }

        // Game loop
        function gameLoop() {
            if (!isGameActive) return;

            obstacles.forEach((obs, index) => {
                const pos = obs.element.getAttribute('position');
                pos.z += obstacleSpeed;
                obs.element.setAttribute('position', pos);

                if (checkCollision(pos, obs)) {
                    gameOver();
                    return;
                }

                if (pos.z > 3) {
                    obs.element.remove();
                    obstacles.splice(index, 1);
                    score += 10;
                    updateScore();
                }
            });

            requestAnimationFrame(gameLoop);
        }

        // Collision detection
        function checkCollision(obstaclePos, obstacle) {
            const playerPos = isVRMode ? rig.getAttribute('position') : player.getAttribute('position');
            const spherePos = {
                x: playerPos.x,
                y: (playerPos.y + playerY) - 0.5,
                z: playerPos.z - 1.5
            };
            
            const sphereHitbox = {
                x: spherePos.x,
                y: spherePos.y,
                z: spherePos.z,
                radius: 0.2
            };
            
            const obstacleHitbox = {
                x: obstaclePos.x,
                y: obstaclePos.y + (obstacle.isHigh ? 0.9 : 0.5),
                z: obstaclePos.z,
                width: 1.0,
                height: obstacle.isHigh ? 1.8 : 1.0,
                depth: 1.0
            };
            
            const xDistance = Math.abs(sphereHitbox.x - obstacleHitbox.x);
            const xCollision = xDistance < (obstacleHitbox.width / 2 + sphereHitbox.radius);
            
            const yDistance = Math.abs(sphereHitbox.y - obstacleHitbox.y);
            const yCollision = yDistance < (obstacleHitbox.height / 2 + sphereHitbox.radius);
            
            const zDistance = Math.abs(sphereHitbox.z - obstacleHitbox.z);
            const zCollision = zDistance < (obstacleHitbox.depth / 2 + sphereHitbox.radius);
            
            return (xCollision && yCollision && zCollision);
        }

        // Jump function
        function performJump() {
            if (!gameStarted) {
                startGame();
                return;
            }
            if (!isGameActive || isPlayerMoving) return;
            
            playerY = 2.4;
            isPlayerMoving = true;
            
            if (isVRMode) {
                rig.setAttribute('animation', {
                    property: 'position',
                    to: `0 ${playerY - 1.6} 0`,
                    dur: 300,
                    easing: 'easeOutCubic'
                });
            } else {
                player.setAttribute('animation', {
                    property: 'position',
                    to: `0 ${playerY} 0`,
                    dur: 300,
                    easing: 'easeOutCubic'
                });
            }
            
            setTimeout(() => {
                if (playerY === 2.4) {
                    playerY = 1.6;
                    if (isVRMode) {
                        rig.setAttribute('animation', {
                            property: 'position',
                            to: '0 0 0',
                            dur: 400,
                            easing: 'easeInOutCubic'
                        });
                    } else {
                        player.setAttribute('animation', {
                            property: 'position',
                            to: `0 ${playerY} 0`,
                            dur: 400,
                            easing: 'easeInOutCubic'
                        });
                    }
                    setTimeout(() => {
                        isPlayerMoving = false;
                    }, 400);
                }
            }, 2000);
        }

        // Duck function
        function performDuck() {
            if (!gameStarted) {
                startGame();
                return;
            }
            if (!isGameActive || isPlayerMoving) return;
            
            playerY = 0.8;
            isPlayerMoving = true;
            
            if (isVRMode) {
                rig.setAttribute('animation', {
                    property: 'position',
                    to: `0 ${playerY - 1.6} 0`,
                    dur: 250,
                    easing: 'easeOutCubic'
                });
            } else {
                player.setAttribute('animation', {
                    property: 'position',
                    to: `0 ${playerY} 0`,
                    dur: 250,
                    easing: 'easeOutCubic'
                });
            }
            
            setTimeout(() => {
                if (playerY === 0.8) {
                    playerY = 1.6;
                    if (isVRMode) {
                        rig.setAttribute('animation', {
                            property: 'position',
                            to: '0 0 0',
                            dur: 400,
                            easing: 'easeInOutCubic'
                        });
                    } else {
                        player.setAttribute('animation', {
                            property: 'position',
                            to: `0 ${playerY} 0`,
                            dur: 400,
                            easing: 'easeInOutCubic'
                        });
                    }
                    setTimeout(() => {
                        isPlayerMoving = false;
                    }, 400);
                }
            }, 2000);
        }

        // VR Controller Events
        leftHand.addEventListener('triggerdown', performJump);
        leftHand.addEventListener('gripdown', performJump);
        leftHand.addEventListener('abuttondown', performDuck);

        rightHand.addEventListener('triggerdown', performJump);
        rightHand.addEventListener('gripdown', performJump);
        rightHand.addEventListener('bbuttondown', performDuck);
        rightHand.addEventListener('xbuttondown', performDuck);

        // Keyboard controls
        document.addEventListener('keydown', function(event) {
            if (event.code === 'Space') {
                performJump();
            } else if (event.code === 'KeyS') {
                if (gameStarted) performDuck();
            } else if (event.code === 'KeyR' && gameStarted) {
                playerY = 1.6;
                isPlayerMoving = false;
                
                if (isVRMode) {
                    rig.setAttribute('animation', {
                        property: 'position',
                        to: '0 0 0',
                        dur: 300,
                        easing: 'easeInOutCubic'
                    });
                } else {
                    player.setAttribute('animation', {
                        property: 'position',
                        to: `0 ${playerY} 0`,
                        dur: 300,
                        easing: 'easeInOutCubic'
                    });
                }
            }
        });

        // Click controls
        document.addEventListener('click', function() {
            if (!gameStarted) {
                startGame();
            } else if (!isGameActive) {
                restartGame();
            } else if (!isVRMode) {
                performJump();
            }
        });

        // Spawn obstacles
        function spawnObstacles() {
            if (!isGameActive) return;
            
            createObstacle();
            
            if (score > 0 && score % 150 === 0) {
                obstacleSpeed = Math.min(0.15, obstacleSpeed + 0.008);
                spawnRate = Math.max(2000, spawnRate - 150);
            }
            
            const randomDelay = spawnRate + (Math.random() - 0.5) * 1000;
            setTimeout(spawnObstacles, Math.max(2000, randomDelay));
        }

        function updateScore() {
            scoreText.setAttribute('value', `Score: ${score}`);
            scoreText.setAttribute('animation__score', {
                property: 'scale',
                to: '1.2 1.2 1.2',
                dur: 150,
                dir: 'alternate',
                loop: 2,
                easing: 'easeInOutQuad'
            });
        }

        function gameOver() {
            isGameActive = false;
            isPlayerMoving = false;
            stopTimer();
            saveHighScores();
            
            // Determine if new record was set
            let recordText = '';
            if (score > bestScore && gameTime > bestTime) {
                recordText = '🎉 NEW RECORDS! 🎉\n';
            } else if (score > bestScore) {
                recordText = '🏆 NEW HIGH SCORE! 🏆\n';
            } else if (gameTime > bestTime) {
                recordText = '⏱️ NEW TIME RECORD! ⏱️\n';
            }
            
            instructionsText.setAttribute('visible', false);
            statusText.setAttribute('visible', false);
            gameOverText.setAttribute('visible', true);
            gameOverText.setAttribute('value', 
                `💀 GAME OVER! 💀\n${recordText}Score: ${score} | Time: ${formatFinalTime()}\nBest: ${bestScore} | ${Math.floor(bestTime/60)}:${(bestTime%60).toString().padStart(2,'0')}\n\nClick to Try Again!`);
            
            gameOverText.setAttribute('animation__appear', {
                property: 'scale',
                from: '0 0 0',
                to: '1 1 1',
                dur: 600,
                easing: 'easeOutBounce'
            });
        }

        function restartGame() {
            isGameActive = true;
            playerY = 1.6;
            score = 0;
            obstacleSpeed = 0.08;
            spawnRate = 3500;
            isPlayerMoving = false;
            gameTime = 0;

            obstacles.forEach(obs => obs.element.remove());
            obstacles = [];

            player.setAttribute('position', '0 1.6 0');
            rig.setAttribute('position', '0 0 0');
            player.removeAttribute('animation');
            rig.removeAttribute('animation');

            gameOverText.setAttribute('visible', false);
            instructionsText.setAttribute('visible', true);
            statusText.setAttribute('visible', true);
            statusText.setAttribute('value', '🎯 Avoid the red obstacles to survive!');
            updateScore();
            startTimer();

            gameLoop();
            setTimeout(spawnObstacles, 2000);
        }

        // Initialize game with compact intro screen
        document.querySelector('a-scene').addEventListener('loaded', function() {
            console.log('Game loaded - compact introduction screen ready');
        });
    </script>
</body>
</html>
