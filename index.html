<!DOCTYPE html>
<html>
<head>
    <script src="https://aframe.io/releases/1.7.1/aframe.min.js"></script>
</head>
<body>
    <a-scene background="color: #87CEEB" renderer="antialias: true; colorManagement: true" 
             vr-mode-ui="enabled: true" device-orientation-permission-ui="enabled: true">
        <!-- Enhanced lighting -->
        <a-light type="ambient" color="#404040" intensity="0.6"></a-light>
        <a-light type="directional" position="0 5 0" color="#ffffff" intensity="1.2" 
                 shadow="type: pcf; mapSize: 2048"></a-light>
        
        <!-- Ground with improved materials -->
        <a-plane position="0 -1 0" rotation="-90 0 0" width="8" height="100" 
                 material="color: #4a9a4a; roughness: 0.8; metalness: 0.1"
                 shadow="receive: true"></a-plane>
        
        <!-- VR Rig for Oculus -->
        <a-entity id="rig" position="0 0 0">
            <!-- Player camera/avatar with VR controls -->
            <a-camera id="player" position="0 1.6 0" wasd-controls="enabled: false" 
                      look-controls="enabled: true">
                <!-- Player visual indicator -->
                <a-sphere position="0 -0.5 -1.5" radius="0.2" 
                         material="color: #4285f4; metalness: 0.3; roughness: 0.4"
                         shadow="cast: true"></a-sphere>
            </a-camera>

            <!-- Oculus Touch Controllers -->
            <a-entity id="leftHand" 
                      hand-controls="hand: left; handModelStyle: lowPoly; color: #ffcccc"
                      oculus-touch-controls="hand: left"
                      raycaster="objects: .clickable"
                      line="color: #118A7E"></a-entity>

            <a-entity id="rightHand" 
                      hand-controls="hand: right; handModelStyle: lowPoly; color: #ffcccc"
                      oculus-touch-controls="hand: right"
                      raycaster="objects: .clickable"
                      line="color: #118A7E"></a-entity>
        </a-entity>
        
        <!-- Obstacles container -->
        <a-entity id="obstacles"></a-entity>
        
        <!-- Game Introduction Screen -->
        <a-entity id="introScreen" visible="true">
            <a-text position="0 3 -5" align="center" 
                    value="AVOID THE OBSTACLES" 
                    material="color: #ff6b35; shader: msdf" width="12" font="roboto"
                    animation="property: scale; to: 1.1 1.1 1.1; dur: 2000; dir: alternate; loop: true; easing: easeInOutSine"></a-text>
            
            <a-text position="0 2 -5" align="center" 
                    value="Welcome to the ultimate obstacle dodging challenge!\nYour blue sphere must avoid the incoming red obstacles." 
                    material="color: white; shader: msdf" width="8" font="roboto"></a-text>
            
            <a-text position="0 1 -5" align="center" 
                    value="CONTROLS:\n• SPACEBAR or VR TRIGGER = Jump (avoid low obstacles)\n• S KEY or VR A/X BUTTON = Duck (avoid high obstacles)\n• R KEY = Return to standing position" 
                    material="color: yellow; shader: msdf" width="6" font="roboto"></a-text>
            
            <a-text position="0 -0.5 -5" align="center" 
                    value="GAMEPLAY:\n• Obstacles come in two types: HIGH and LOW\n• Jump over low obstacles (short red boxes)\n• Duck under high obstacles (tall red boxes)\n• Score points for each obstacle you avoid\n• Game gets faster as your score increases!" 
                    material="color: #4285f4; shader: msdf" width="6" font="roboto"></a-text>
            
            <a-text id="startPrompt" position="0 -2 -5" align="center" 
                    value="CLICK ANYWHERE OR PRESS SPACEBAR TO START!" 
                    material="color: #00ff00; shader: msdf" width="8" font="roboto"
                    animation="property: scale; to: 1.2 1.2 1.2; dur: 1000; dir: alternate; loop: true; easing: easeInOutQuad"></a-text>
            
            <!-- Demo obstacles for visual reference -->
            <a-box position="-2 1.3 -6" width="0.8" height="1.4" depth="0.8" 
                   material="color: #e74c3c; roughness: 0.3; metalness: 0.7"
                   animation="property: rotation; to: 0 360 0; dur: 3000; loop: true"></a-box>
            <a-text position="-2 0.3 -6" align="center" value="HIGH\nDUCK!" 
                    material="color: white; shader: msdf" width="4"></a-text>
            
            <a-box position="2 0.4 -6" width="0.8" height="0.8" depth="0.8" 
                   material="color: #c0392b; roughness: 0.3; metalness: 0.7"
                   animation="property: rotation; to: 0 360 0; dur: 3000; loop: true"></a-box>
            <a-text position="2 -0.4 -6" align="center" value="LOW\nJUMP!" 
                    material="color: white; shader: msdf" width="4"></a-text>
        </a-entity>
        
        <!-- Game UI Elements (hidden during intro) -->
        <a-text id="instructions" position="0 2.5 -4" align="center" 
                value="VR: Trigger/Grip = Jump | A/X Button = Duck\nKeyboard: SPACEBAR = Jump | S = Duck" 
                material="color: white; shader: msdf" width="5" font="roboto"
                look-at="#player" visible="false"></a-text>
        
        <a-text id="score" position="-3 2.8 -4" align="left" 
                value="Score: 0" material="color: yellow; shader: msdf" 
                width="4" font="roboto"
                look-at="#player" visible="false"></a-text>
        
        <a-text id="gameOver" position="0 2 -4" align="center" 
                value="GAME OVER!\nTrigger to Restart" 
                material="color: red; shader: msdf" width="8" 
                font="roboto" visible="false"
                look-at="#player"></a-text>

        <!-- VR Control Indicators -->
        <a-text id="vrStatus" position="3 2.8 -4" align="right" 
                value="VR Ready!" material="color: green; shader: msdf" 
                width="3" font="roboto" visible="false"
                look-at="#player"></a-text>
    </a-scene>

    <script>
        // Game state
        let isGameActive = false; // Start with intro screen
        let gameStarted = false;
        let playerY = 1.6;
        let obstacles = [];
        let score = 0;
        let obstacleSpeed = 0.08;
        let spawnRate = 3500;
        let isPlayerMoving = false;
        let isVRMode = false;

        // DOM elements
        const player = document.querySelector('#player');
        const rig = document.querySelector('#rig');
        const obstacleContainer = document.querySelector('#obstacles');
        const scoreText = document.querySelector('#score');
        const gameOverText = document.querySelector('#gameOver');
        const instructionsText = document.querySelector('#instructions');
        const vrStatusText = document.querySelector('#vrStatus');
        const leftHand = document.querySelector('#leftHand');
        const rightHand = document.querySelector('#rightHand');
        const introScreen = document.querySelector('#introScreen');

        // Detect VR mode
        document.querySelector('a-scene').addEventListener('enter-vr', function() {
            isVRMode = true;
            vrStatusText.setAttribute('visible', true);
            console.log('Entered VR mode');
        });

        document.querySelector('a-scene').addEventListener('exit-vr', function() {
            isVRMode = false;
            vrStatusText.setAttribute('visible', false);
            console.log('Exited VR mode');
        });

        // Start the game
        function startGame() {
            if (gameStarted) return;
            
            gameStarted = true;
            isGameActive = true;
            
            // Hide intro screen with animation
            introScreen.setAttribute('animation', {
                property: 'scale',
                to: '0 0 0',
                dur: 500,
                easing: 'easeInCubic'
            });
            
            setTimeout(() => {
                introScreen.setAttribute('visible', false);
                
                // Show game UI
                instructionsText.setAttribute('visible', true);
                scoreText.setAttribute('visible', true);
                
                // Start game systems
                updateScore();
                gameLoop();
                setTimeout(spawnObstacles, 2000);
            }, 500);
        }

        // Create obstacles
        function createObstacle() {
            if (!isGameActive) return;

            const obstacle = document.createElement('a-box');
            const isHighObstacle = Math.random() < 0.3;
            const xPos = (Math.random() - 0.5) * 2;
            
            obstacle.setAttribute('position', {
                x: xPos,
                y: isHighObstacle ? 2.2 : 0.5,
                z: -25
            });
            
            obstacle.setAttribute('geometry', {
                width: 1,
                height: isHighObstacle ? 1.8 : 1,
                depth: 1
            });
            
            obstacle.setAttribute('material', {
                color: isHighObstacle ? '#e74c3c' : '#c0392b',
                roughness: 0.3,
                metalness: 0.7,
                emissive: '#330000',
                emissiveIntensity: 0.1
            });
            
            obstacle.setAttribute('shadow', 'cast: true; receive: true');
            
            obstacle.setAttribute('animation', {
                property: 'rotation',
                to: '0 360 0',
                dur: 4000,
                loop: true,
                easing: 'linear'
            });

            obstacle.setAttribute('animation__pulse', {
                property: 'scale',
                to: '1.1 1.1 1.1',
                dur: 1500,
                dir: 'alternate',
                loop: true,
                easing: 'easeInOutSine'
            });

            obstacleContainer.appendChild(obstacle);
            obstacles.push({
                element: obstacle,
                isHigh: isHighObstacle,
                x: xPos
            });
        }

        // Game loop
        function gameLoop() {
            if (!isGameActive) return;

            obstacles.forEach((obs, index) => {
                const pos = obs.element.getAttribute('position');
                pos.z += obstacleSpeed;
                obs.element.setAttribute('position', pos);

                if (checkCollision(pos, obs)) {
                    gameOver();
                    return;
                }

                if (pos.z > 3) {
                    obs.element.remove();
                    obstacles.splice(index, 1);
                    score += 10;
                    updateScore();
                }
            });

            requestAnimationFrame(gameLoop);
        }

        // Proper hitbox collision detection
        function checkCollision(obstaclePos, obstacle) {
            const playerPos = isVRMode ? rig.getAttribute('position') : player.getAttribute('position');
            const spherePos = {
                x: playerPos.x,
                y: (playerPos.y + playerY) - 0.5,
                z: playerPos.z - 1.5
            };
            
            const sphereHitbox = {
                x: spherePos.x,
                y: spherePos.y,
                z: spherePos.z,
                radius: 0.2
            };
            
            const obstacleHitbox = {
                x: obstaclePos.x,
                y: obstaclePos.y + (obstacle.isHigh ? 0.9 : 0.5),
                z: obstaclePos.z,
                width: 1.0,
                height: obstacle.isHigh ? 1.8 : 1.0,
                depth: 1.0
            };
            
            const xDistance = Math.abs(sphereHitbox.x - obstacleHitbox.x);
            const xCollision = xDistance < (obstacleHitbox.width / 2 + sphereHitbox.radius);
            
            const yDistance = Math.abs(sphereHitbox.y - obstacleHitbox.y);
            const yCollision = yDistance < (obstacleHitbox.height / 2 + sphereHitbox.radius);
            
            const zDistance = Math.abs(sphereHitbox.z - obstacleHitbox.z);
            const zCollision = zDistance < (obstacleHitbox.depth / 2 + sphereHitbox.radius);
            
            if (xCollision && yCollision && zCollision) {
                console.log(`COLLISION DETECTED!`);
                return true;
            }
            
            return false;
        }

        // Jump function
        function performJump() {
            if (!gameStarted) {
                startGame();
                return;
            }
            if (!isGameActive || isPlayerMoving) return;
            
            playerY = 2.4;
            isPlayerMoving = true;
            
            if (isVRMode) {
                rig.setAttribute('animation', {
                    property: 'position',
                    to: `0 ${playerY - 1.6} 0`,
                    dur: 300,
                    easing: 'easeOutCubic'
                });
            } else {
                player.setAttribute('animation', {
                    property: 'position',
                    to: `0 ${playerY} 0`,
                    dur: 300,
                    easing: 'easeOutCubic'
                });
            }
            
            setTimeout(() => {
                if (playerY === 2.4) {
                    playerY = 1.6;
                    if (isVRMode) {
                        rig.setAttribute('animation', {
                            property: 'position',
                            to: '0 0 0',
                            dur: 400,
                            easing: 'easeInOutCubic'
                        });
                    } else {
                        player.setAttribute('animation', {
                            property: 'position',
                            to: `0 ${playerY} 0`,
                            dur: 400,
                            easing: 'easeInOutCubic'
                        });
                    }
                    setTimeout(() => {
                        isPlayerMoving = false;
                    }, 400);
                }
            }, 2000);
        }

        // Duck function
        function performDuck() {
            if (!gameStarted) {
                startGame();
                return;
            }
            if (!isGameActive || isPlayerMoving) return;
            
            playerY = 0.8;
            isPlayerMoving = true;
            
            if (isVRMode) {
                rig.setAttribute('animation', {
                    property: 'position',
                    to: `0 ${playerY - 1.6} 0`,
                    dur: 250,
                    easing: 'easeOutCubic'
                });
            } else {
                player.setAttribute('animation', {
                    property: 'position',
                    to: `0 ${playerY} 0`,
                    dur: 250,
                    easing: 'easeOutCubic'
                });
            }
            
            setTimeout(() => {
                if (playerY === 0.8) {
                    playerY = 1.6;
                    if (isVRMode) {
                        rig.setAttribute('animation', {
                            property: 'position',
                            to: '0 0 0',
                            dur: 400,
                            easing: 'easeInOutCubic'
                        });
                    } else {
                        player.setAttribute('animation', {
                            property: 'position',
                            to: `0 ${playerY} 0`,
                            dur: 400,
                            easing: 'easeInOutCubic'
                        });
                    }
                    setTimeout(() => {
                        isPlayerMoving = false;
                    }, 400);
                }
            }, 2000);
        }

        // VR Controller Events
        leftHand.addEventListener('triggerdown', performJump);
        leftHand.addEventListener('gripdown', performJump);
        leftHand.addEventListener('abuttondown', performDuck);

        rightHand.addEventListener('triggerdown', performJump);
        rightHand.addEventListener('gripdown', performJump);
        rightHand.addEventListener('bbuttondown', performDuck);
        rightHand.addEventListener('xbuttondown', performDuck);

        // Keyboard controls
        document.addEventListener('keydown', function(event) {
            if (event.code === 'Space') {
                performJump();
            } else if (event.code === 'KeyS') {
                if (gameStarted) performDuck();
            } else if (event.code === 'KeyR' && gameStarted) {
                playerY = 1.6;
                isPlayerMoving = false;
                
                if (isVRMode) {
                    rig.setAttribute('animation', {
                        property: 'position',
                        to: '0 0 0',
                        dur: 300,
                        easing: 'easeInOutCubic'
                    });
                } else {
                    player.setAttribute('animation', {
                        property: 'position',
                        to: `0 ${playerY} 0`,
                        dur: 300,
                        easing: 'easeInOutCubic'
                    });
                }
            }
        });

        // Click controls
        document.addEventListener('click', function() {
            if (!gameStarted) {
                startGame();
            } else if (!isGameActive) {
                restartGame();
            } else if (!isVRMode) {
                performJump();
            }
        });

        // Spawn obstacles
        function spawnObstacles() {
            if (!isGameActive) return;
            
            createObstacle();
            
            if (score > 0 && score % 150 === 0) {
                obstacleSpeed = Math.min(0.15, obstacleSpeed + 0.008);
                spawnRate = Math.max(2000, spawnRate - 150);
            }
            
            const randomDelay = spawnRate + (Math.random() - 0.5) * 1000;
            setTimeout(spawnObstacles, Math.max(2000, randomDelay));
        }

        function updateScore() {
            scoreText.setAttribute('value', `Score: ${score}`);
            scoreText.setAttribute('animation__score', {
                property: 'scale',
                to: '1.2 1.2 1.2',
                dur: 150,
                dir: 'alternate',
                loop: 2,
                easing: 'easeInOutQuad'
            });
        }

        function gameOver() {
            isGameActive = false;
            isPlayerMoving = false;
            
            instructionsText.setAttribute('visible', false);
            gameOverText.setAttribute('visible', true);
            gameOverText.setAttribute('value', `GAME OVER!\nFinal Score: ${score}\nClick to Restart`);
            
            gameOverText.setAttribute('animation__appear', {
                property: 'scale',
                from: '0 0 0',
                to: '1 1 1',
                dur: 600,
                easing: 'easeOutBounce'
            });
        }

        function restartGame() {
            isGameActive = true;
            playerY = 1.6;
            score = 0;
            obstacleSpeed = 0.08;
            spawnRate = 3500;
            isPlayerMoving = false;

            obstacles.forEach(obs => obs.element.remove());
            obstacles = [];

            player.setAttribute('position', '0 1.6 0');
            rig.setAttribute('position', '0 0 0');
            player.removeAttribute('animation');
            rig.removeAttribute('animation');

            gameOverText.setAttribute('visible', false);
            instructionsText.setAttribute('visible', true);
            updateScore();

            gameLoop();
            setTimeout(spawnObstacles, 2000);
        }

        // Initialize game with intro screen
        document.querySelector('a-scene').addEventListener('loaded', function() {
            console.log('Game loaded - showing introduction screen');
        });
    </script>
</body>
</html>
